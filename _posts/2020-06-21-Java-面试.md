---
title: Java 一些面试点
date: 2022-06-21 09:00:00
description: Java 基础 + 高级
categories:
- Develop
tag: 
- Java
---

# Java基础

## Java面向对象

### 面向对象的特性以及理解

**封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。**面向对象的本质就是将现实世界描绘成一系列完全自制、封闭的对象。我们编写一个类就是对数据和数据操作的封装，我们在类中编写的方法就是对实现细节的一种封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。

**继承：继承是从已有类得到继承信息创建新类的过程。**提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。

**多态：多态是指允许不同子类型的对象对同一消息作出不同的相应。**简单的说就是用同样的对象引用调用同样的方法，但是做了不同的事情。多态性分为编译时的多态和运行时的多态。如果将对象的方法视为对象外界提供的服务，那么运行时的多态可以解释为：当 A 系统访问 B 系统提供的服务时，B 系统有多种提供服务的方式，但一切对 A 系统来说都是透明的。**方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写 （override）实现的是运行时的多态性（也称为后绑定）。**运行时的多态是面向对象最精髓的东西，要实现多态需要做 两件事：1. 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2. 对象造型（用父类型引用引用子类型对 象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。

**抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。**抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。

> 注意：默认情况下，面向对象有 3 大特性即封装、继承、多态，但如果让说出 4 大特性，我们就把抽象 加上去。

### 访问权限修饰符 public、private、protected, 以及不写（默认）时的区别

|  修饰符   | 当前类 | 同包 | 子类 | 其他包 |
| :-------: | :----: | :--: | :--: | :----: |
|  public   |   √    |  √   |  √   |   √    |
| protected |   √    |  √   |  √   |   ×    |
|  default  |   √    |  √   |  ×   |   ×    |
|  private  |   √    |  ×   |  ×   |   ×    |

### 接口和抽象类的区别

**抽象类：**

- 含有 abstract 修饰的类即为抽象类，抽象类不能创建实例对象。
- 含有 abstract 方法的类必须定义为抽象类，抽象类中的方法不必是抽象的。
- 抽象类中定义抽象方法必须在具体子类中实现，所以，不能有抽象构造方法或抽象静态方法。
- 如果子类没有实现抽象父类中的方法，那么子类也必须定义为 abstract 类型。

**接口：**

- 可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为 public abstract 类型；
- 接口中的成员变量类型默认为 public static final.

**区别：**

1. 抽象类可以有构造方法，接口中不能有构造方法。
2. 抽象类中可以有普通成员变量，接口中没有普通成员变量。
3. 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。
4. 抽象类中的抽象方法的访问类型可以是 public、protected 和默认类型，但接口中的抽象方法只能是 public 类型的，并且默认修饰即为 public abstract 类型。
5. 抽象类中可以包含静态方法，接口中不能包含静态方法。
6. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是 public static final 类型，并且默认即为 public static final 类型。
7. 一个类可以实现多个接口，但只能继承一个抽象类。

###  Spring MVC常用的注解

```java
@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。

@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。

@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。
```

### Spring中依赖混淆点

1、spring web 和 spring webmvc的区别

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-web</artifactId>
    <version>5.2.1.RELEASE</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>5.2.1.RELEASE</version>
</dependency>
```

> spring-web provides core HTTP integration, including some handy Servlet filters, Spring HTTP Invoker, infrastructure to integrate with other web frameworks and HTTP technologies e.g. Hessian, Burlap.
>
> spring-webmvc is an implementation of Spring MVC. spring-webmvc depends on on spring-web, thus including it will transitively add spring-web. You don't have to add spring-webexplicitly.
>
> You should depend only on spring-web if you don't use Spring MVC but want to take advantage of other web-related technologies that Spring supports.
>
> spring-web 提供了核心 HTTP 集成，包括一些便捷的 servlet 过滤器， Spring HTTP 调用，用于集成其它 web 框架的基础结构以及技术（Hessian，Burlap）。
>
> spring-webmvc 是 Spring MVC 的一个实现。spriing-webmvc 依赖于 spring-web，这样包含它就会间接地添加 spring-web。不必显示添加 spring-web。
>
> 如果你不使用 Spring MVC ，但想要借助其它 Spring 支持的 web 相关技术的优势，那么你只需依赖 spring-web 。

2、spring context 和 spring context-support的区别

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.2.1.RELEASE</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context-support</artifactId>
    <version>5.2.1.RELEASE</version>
</dependency>
```

spring-context 建立在 core 和 beans 之上，提供了更高层的 API。其核心是 ApplicationContext。
spring-context-support 则是为将第三方库整合进 Spring 应用上下文 提供支持。